-------------------------------------------------------------------------------
-- Title      : Revolution tick generator  
-- Project    : RF DDS Distribution over WR
-------------------------------------------------------------------------------
-- File       : Trev_Gen_Module.vhd
-- Author     : E. Calvo
-- Company    : CERN BE-CO-HT
-- Platform   : FPGA-generic
-- Standard   : VHDL'93
-------------------------------------------------------------------------------
-- Description: 
--
-- This block derives Revolution ticks from the  Bunch clock ticks.
-- Revolution ticks are time stamped in the WR Master node with a resolution
-- of 1ns and sent in frames to the WR slave. The following GW is implemented 
-- at the slave node. It is assumend that data contained in these frames
-- has been recovered and they are feed into these module (Tstamp2_i and Tstamp1_i).
-- It is assumed also that the Bunch clock has been obtained using a 
-- DDS technique, and that it has been compensated for the Beam time of 
-- flight effect already.
--
-------------------------------------------------------------------------------
--
-- Copyright (c) 2016 CERN
--
-- This source file is free software; you can redistribute it   
-- and/or modify it under the terms of the GNU Lesser General   
-- Public License as published by the Free Software Foundation;
-- either version 2.1 of the License, or (at your option) any
-- later version.                                               
--
-- This source is distributed in the hope that it will be
-- useful, but WITHOUT ANY WARRANTY; without even the implied
-- warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-- PURPOSE.  See the GNU Lesser General Public License for more
-- details.
--
-- You should have received a copy of the GNU Lesser General
-- Public License along with this source; if not, download it
-- from http://www.gnu.org/licenses/lgpl-2.1.html
--
-------------------------------------------------------------------------------
-- Revisions  :
-- Date        Version  Author          Description
-- 2016-06-15  0.1      ecalvo          First version, creation.
-------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.TrevGen_wb_slave_pkg.all;

entity TrevGen_Module is
    port(
        -- System signals
        rst_n_i    :  in std_logic;
        clk_sys_i  :  in std_logic;     -- 62.5MHz
        clk_125m_i     : in std_logic;  -- 125MHz
        -- Trev module signals
        B_clk_i    :  in std_logic; 
        WRcyc_i    :  in unsigned(27 downto 0); 
        Rev_clk_o  :  out std_logic ;
        -- Wishbone interface
        wb_adr_i   :  in std_logic_vector(31 downto 0);
        wb_data_i  :  in std_logic_vector(31 downto 0);
        wb_data_o  :  out std_logic_vector(31 downto 0);
        wb_cyc_i   :  in std_logic;
        wb_sel_i   :  in std_logic_vector(3 downto 0);
        wb_stb_i   :  in std_logic;
        wb_we_i    :  in std_logic;
        wb_ack_o   :  out std_logic;
        wb_stall_o :  out std_logic;
        regs_i     :  in  t_TrevGen_in_registers;
        regs_o     :  out t_TrevGen_out_registers  );
end entity TrevGen_Module;

architecture rtl of TrevGen_Module is

  component TrevGen_wb_slave is
       port (
         rst_n_i                                  : in     std_logic;
         clk_sys_i                                : in     std_logic;
         wb_adr_i                                 : in     std_logic_vector(2 downto 0);
         wb_dat_i                                 : in     std_logic_vector(31 downto 0);
         wb_dat_o                                 : out    std_logic_vector(31 downto 0);
         wb_cyc_i                                 : in     std_logic;
         wb_sel_i                                 : in     std_logic_vector(3 downto 0);
         wb_stb_i                                 : in     std_logic;
         wb_we_i                                  : in     std_logic;
         wb_ack_o                                 : out    std_logic;
         wb_stall_o                               : out    std_logic;
         regs_i                                   : in     t_TrevGen_in_registers;
         regs_o                                   : out    t_TrevGen_out_registers );
  end component;
 
  type t_State is (Init, Update, Wait_Target, Gate_Opened, Wait_Update);
  signal State : t_State_GateGenFSM ;     
 
  signal BclkGate: std_logic;
  signal phase: unsigned(2 downto 0);
  begin WRcycTarget: unsigned(27 downto 0);

  -- instantiate the wb interface generated with wbgen2
    cmp_TrevGen_wb_slave: TrevGen_wb_slave port map(
        rst_n_i     =>  rst_n_i,
        clk_sys_i   =>  clk_sys_i,
        wb_adr_i    =>  wb_adr_i(4 downto 2),
        wb_dat_i    =>  wb_data_i,
        wb_dat_o    =>  wb_data_o,
        wb_cyc_i    =>  wb_cyc_i,
        wb_sel_i    =>  wb_sel_i,
        wb_stb_i    =>  wb_stb_i,
        wb_we_i     =>  wb_we_i,
        wb_ack_o    =>  wb_ack_o,
        wb_stall_o  =>  wb_stall_o,
        regs_i      =>  regs_i,
        regs_o      =>  regs_o); 

  -- --------------------------------------------
  --    FSM 
  -- --------------------------------------------

  proc_Update_FSM_State: process (clk_125m_i)
  begin
  
    if rising_edge(clk_125m_i) then
        if (rst_n_i = '0') then
            State  <= Init;
        else
           case State is

              when Init =>
                  
                 if (regs_o.trevgen_strobe_p_o = '1') then
                    State <= Update; 
                 end if;

              when Update => 
                 State <= Wait_Target; 
               
              when Wait_Target => 
                 if (WRcyc_i = WRcycTarget -1) then
                    State <= Gate_opened; 
                 end if;

              when Gate_opened =>
                 if (WRcyc_i = WRcycTarget +3) then
                    State <= Wait_Update;
                 end if;

              when Wait_Update =>
                 if (regs_o.trevgen_strobe_p_o = '1') then
                    State <= Update; 
                 end if;

              when others => 
                 State  <= Init;
           end case;
        end if;
    end if;
  end process;

 proc_Update_FSM_Outputs: process (rst_n_i, clk_125m_i, clk_sys_i)
  begin
  
        if (rst_n_i = '0') then
            regs_i.trevgen_lc_next_tick_i <= (regs_i.trevgen_lc_next_tick_i'range => '0');
            regs_i.trevgen_lc_trev_i  <= (regs_i.trevgen_lc_trev_i'range => '0');
            BclkGate <= '0';
            phase <= (phase'range => '0');
            WRcycTarget <= (WRcycTarget'range => '0');
        else
           case State is

              when Init =>

                 if rising_edge(clk_sys_i) then 
                    regs_i.trevgen_lc_next_tick_i <= (regs_i.trevgen_lc_next_tick_i'range => '0');
                    regs_i.trevgen_lc_trev_i  <= (regs_i.trevgen_lc_trev_i'range => '0');
                 end if;

                 if rising_edge(clk_125m_i) then 
                    phase <= (phase'range => '0');
                    WRcycTarget <= (WRcycTarget'range => '0');
                 end if;

                 if rising_edge(clk_125m_i) then
                    BclkGate <= '0';
                 end if;

              when Update => 
                 
                 if rising_edge(clk_sys_i) then 
                    regs_i.trevgen_lc_next_tick_i <= regs_o.trevgen_rm_next_tick_o;
                    regs_i.trevgen_lc_trev_i  <=  regs_o.trevgen_rm_trev_o;
                 end if;
                 if rising_edge(clk_125m_i) then
                    phase <= regs_o.trevgen_rm_next_tick_o(2 downto 0);
                    WRcycTarget <= ; regs_o.trevgen_rm_next_tick_o(30 downto 3);
                 end if;
                 if rising_edge(clk_125m_i) then
                    BclkGate <= '0';
                 end if;

              when Wait_Target => 
                 if (WRcyc_i = WRcycTarget -1) then
                    if (phase < 4) then
                       if rising_edge(clk_125m_i) then
                          BclkGate <= '1';
                       end if;
                    else
                       if falling_edge(clk_125m_i) then   -- **** Falling Edge in this case !!
                          BclkGate <= '1';
                       end if; 
                    end if;
                 else
                    if rising_edge(clk_125m_i) then
                       BclkGate <= '0';
                    end if;
                 end if;

              when Gate_opened =>
                 if (WRcyc_i <= WRcycTarget +3) then
                    if (phase < 4) then
                       if rising_edge(clk_125m_i) then
                          BclkGate <= '1';
                       end if;
                    else
                       if falling_edge(clk_125m_i) then
                          BclkGate <= '1';
                       end if; 
                    end if;
                 else
                    if rising_edge(clk_125m_i) then
                       BclkGate <= '0';
                    end if;
                 end if;

              when Wait_Update =>
                 if rising_edge(clk_125m_i) then
                    BclkGate <= '0';
                 end if;                 
           end case;
        end if;
    end if;
  end process;

  end architecture;


